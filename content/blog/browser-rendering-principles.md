---
title: 浏览器渲染原理
date: 2026-01-17
summary: 深入解析浏览器关键渲染路径（CRP），从 HTML 解析到像素渲染的完整流程，涵盖 DOM/CSSOM 构建、渲染树生成、布局绘制以及合成层优化等核心机制，为前端性能优化提供底层理论基础。
---

在前端性能优化领域，理解浏览器如何处理代码是所有方案的底层逻辑。从 HTML 字符串到屏幕上的彩色像素，浏览器引擎经历了一个严谨的工业级过程——关键渲染路径（Critical Rendering Path, CRP）。

## 一、构建阶段：从源码到模型

浏览器首先需要将文本格式的源码解析为内存中的树状数据结构。

### 1.1 DOM (Document Object Model)

浏览器通过标记化（Tokenization）和树状构建，将 HTML 字节流转换为 DOM 树。

- **特性**：它是网页内容的骨架，定义了元素间的父子嵌套关系。
- **增量解析**：DOM 构建是渐进的，HTML 解析器可以在接收到部分字节后立即开始工作。

### 1.2 CSSOM (CSS Object Model)

在解析 HTML 时遇到 CSS 资源，浏览器会同步启动 CSSOM 树的构建。

- **层叠计算**：CSSOM 会计算出页面每个元素的最终样式值（处理继承和权重规则）。
- **渲染阻塞**：CSSOM 构建完成前，浏览器通常会阻塞渲染，以避免"无样式内容闪烁"（FOUC）。

## 二、整合阶段：渲染树 (Render Tree)

当 DOM 和 CSSOM 两棵树准备就绪，浏览器会将它们合并生成渲染树。

- **筛选规则**：渲染树只包含屏幕上可见的节点。
  - `display: none` 的元素及其后代会被剔除。
  - `<head>`、`<script>` 等非展示性标签会被过滤。
  - `visibility: hidden` 的元素则会保留在渲染树中，因为它们仍占据布局空间。

## 三、几何与绘制阶段：Layout & Paint

有了渲染树后，浏览器需要将其映射到物理屏幕的二维坐标系中。

### 3.1 布局 (Layout / Reflow)

浏览器计算渲染树中每个节点在视口（Viewport）内的确切几何属性。

- 这一步会将所有的相对单位（如 `rem`, `vh`, `%`）转换为屏幕上的绝对像素点。
- **重排（Reflow）**：修改元素的几何属性（如宽、高）会触发重新布局，代价极高。

### 3.2 绘制 (Paint / Repaint)

根据布局结果，浏览器将节点的背景、颜色、文本、边框等视觉属性转化为屏幕上的像素。

- **分层设计**：为了提升渲染效率，浏览器并不会将整个页面画在一张画布上，而是将其拆分为多个图层（Layers）。

## 四、核心进阶：合成层（Compositing Layer）

合成（Composite）是渲染流水线的最后一步，也是性能优化的胜负手。

### 4.1 什么是合成层？

合成层是独立于文档流的透明图层。将某些元素提升为独立合成层后，该元素的变换将交给 GPU 处理，而不再占用主线程。

### 4.2 合成层的触发条件

浏览器会自动或根据开发者提示创建合成层，常见触发条件包括：

- **硬件加速属性**：使用 `transform: translate3d()`、`translateZ()` 等 3D 变换。
- **显式声明**：使用 `will-change: transform, opacity` 提前告知浏览器。
- **特定元素**：`<video>`、`<canvas>` 或开启了硬件加速的 `<iframe>`。
- **隐式提升**：当一个 `z-index` 较高的元素覆盖在一个已有的合成层之上时，它也会被强制提升（需警惕"层爆炸"）。

## 五、总结：性能优化的底层准则

基于上述原理，资深前端在编写代码时应遵循以下准则：

- **修改位移优选 transform**：它直接跳过布局和绘制，只触发合成（Composite），实现 60FPS 的丝滑动画。
- **避免频繁触发布局读取**：在 JS 中连续读取 `offsetWidth` 后立即修改样式会强制浏览器提前进行布局（强制同步布局）。
- **合理控制图层数量**：虽然合成层能提速，但每个层都消耗内存。利用 Chrome DevTools 的 Layers 面板监控层分布，防止显存溢出。
